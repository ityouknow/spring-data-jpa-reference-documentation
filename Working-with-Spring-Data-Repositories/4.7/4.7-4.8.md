### 4.7. 事务

repository实例上的CRUD方法默认是事务性的。对于读取操作而言，事务配置的`readOnly`标志需要设置成`true`，其他情况下使用`@Transactional`配置即可，这样就能应用默认的事务配置。细节部分请参阅`SimpleJpaRepository`的javaDoc。如果您需要调整repository中声明的某个方法的事务配置，只需在repository接口中重新声明该方法，如下所示：

例97. 自定义CRUD的事务配置
```JAVA
public interface UserRepository extends CrudRepository<User, Long> {

@Override
@Transactional(timeout = 10)
public List<User> findAll();

// Further query method declarations
}
```

> 这个例子中没有使用到`readOnly`标志，且`findAll()`方法必须在10s内执行完，否则超时。

另外一种可以改变事务行为的方法是使用通常覆盖多个repository的facade或服务实现。其目的是为非CRUD操作定义事务边界：

例98. 使用Facade为多个repository调用定义事务
```JAVA
@Service
class UserManagementImpl implements UserManagement {

private final UserRepository userRepository;
private final RoleRepository roleRepository;

@Autowired
public UserManagementImpl(UserRepository userRepository,
RoleRepository roleRepository) {
this.userRepository = userRepository;
this.roleRepository = roleRepository;
}

@Transactional
public void addRoleToAllUsers(String roleName) {

Role role = roleRepository.findByName(roleName);

for (User user : userRepository.findAll()) {
user.addRole(role);
userRepository.save(user);
}
}
```

> 上面例子中`addRoleToAllUsers(…)`方法的调用会运行在事务内部（参与现有的，如果没有的话则创建一个新的事务）。repositories中的事务配置将被忽略，由外部事务配置决定实际使用的配置。注意，您必须激活`<tx:annotation-driven />`或使用`@EnableTransactionManagement`在正面工作时获得基于注解的配置。上例中假定您使用了组件扫描。

#### 4.7.1. 事务查询方法

只需要在您定义的repository接口上使用`@Transactional`注解，就可让您的查询方法成为事务性的。

例99. 在查询方法中使用@Transactional
```JAVA
@Transactional(readOnly = true)
public interface UserRepository extends JpaRepository<User, Long> {

List<User> findByLastname(String lastname);

@Modifying
@Transactional
@Query("delete from User u where u.active = false")
void deleteInactiveUsers();
}
```

> 因为大多数的查询方法只需要读取数据，您一般会将readOnly标志设置成true。与之相反，`deleteInactiveUsers()`使用了`@Modifying`注解，覆盖了事务注解。因此，该方法执行时的readOnly值是false。

> 对于只读查询使用事务处理是绝对合理的，我们可以通过设置`readOnly`标志来标记它们。但是，这不会作为检查来触发操作查询（尽管有些数据库在只读事务中拒绝`INSERT`和`UPDATE`语句）。`readOnly`标志作为暗示传入底层的JDBC驱动程序来优化性能。此外，Spring将对底层的JPA提供者进行一些优化。例如，当与flush模式设置为`NEVER`的Hibernate一起使用时，当您将一个事务配置成`readOnly`会导致Hibernate跳过脏检查（在大型对象树上有明显改进）。

### 4.8. 锁

要指定使用的锁模式，可以在查询方法上使用`@Lock`注解：

例100. 在查询方法上定义锁元数据
```JAVA
interface UserRepository extends Repository<User, Long> {

// Plain query method
@Lock(LockModeType.READ)
List<User> findByLastname(String lastname);
}
```

此方法声明将导致触发的查询使用`LockModeType` `READ`锁模式。您也可以通过在repository接口中重新声明CRUD方法，添加`@Lock`注解来定义锁。

例101. 在CRUD方法上定义锁元数据
```JAVA
interface UserRepository extends Repository<User, Long> {

// Redeclaration of a CRUD method
@Lock(LockModeType.READ);
List<User> findAll();
}
```


